# Copyright (c) 2012 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

"""Base class for all slave-side build steps. """

from utils import misc
import os
import sys

class BuildStep(object):
  def __init__(self, args, attempts=1):
    self._configuration = args['configuration']
    self._gm_image_subdir = args['gm_image_subdir']
    self._builder_name = args['builder_name']
    self._target_platform = args['target_platform']
    self._revision = int(args['revision'])
    self._attempts = attempts
    # Figure out where we are going to store images generated by GM.
    self._gm_actual_basedir = os.path.join(os.pardir, os.pardir, 'gm', 'actual')
    self._gm_merge_basedir = os.path.join(os.pardir, os.pardir, 'gm', 'merge')
    self._gm_expected_dir = os.path.join('gm', self._gm_image_subdir)
    self._gm_actual_dir = os.path.join(self._gm_actual_basedir,
                                       self._gm_image_subdir)
    self._gm_actual_svn_baseurl = '%s/%s' % (args['autogen_svn_baseurl'],
                                             'gm-actual')
    self._autogen_svn_username_file = '.autogen_svn_username'
    self._autogen_svn_password_file = '.autogen_svn_password'
    
    # Figure out where we are going to store performance output.
    if args['perf_output_basedir'] != 'None':
      self._perf_data_dir = os.path.join(args['perf_output_basedir'],
                                         self._builder_name, 'data')
      self._perf_graphs_dir = os.path.join(args['perf_output_basedir'],
                                           self._builder_name, 'graphs')
    else:
      self._perf_data_dir = None
      self._perf_graphs_dir = None

  def _PathToBinary(self, binary):
    return os.path.join('out', self._configuration, binary)

  def _Run(self, args):
    raise Exception('Cannot instantiate abstract BuildStep')

  @staticmethod
  def Run(StepType):
    args = misc.ArgsToDict(sys.argv)
    step = StepType(args)
    for attempt in range(step._attempts):
      if (step._attempts > 1):
        print '**** %s, attempt %d ****' % (StepType.__name__, attempt + 1)
      if step._Run(args):
        return 0
    raise Exception('%s failed' % StepType.__name__)
