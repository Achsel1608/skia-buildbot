package alerting

import (
	"fmt"
	"strings"
	"time"

	"github.com/skia-dev/glog"
	"go.skia.org/infra/go/email"
	"go.skia.org/infra/go/util"
)

const (
	EMAIL_FOOTER = `<br/><br/>
This email was generated by the Skia alert server.
To snooze or dismiss this alert, visit https://alerts.skia.org
`
	EMAIL_SUBJECT_TMPL = "Skia Alert: %s triggered at %s"
	EMAIL_QUEUE_SIZE   = 100
	EMAIL_RATE_NUMBER  = 10
	EMAIL_RATE_PERIOD  = 30 * time.Minute
)

var (
	emailAuth  *email.GMail        = nil
	emailQueue chan *email.Message = nil
)

// Actions are performed whenever an Alert is updated.
type Action interface {
	Fire(*Alert)
	Followup(*Alert, string)
	String() string
}

type EmailAction struct {
	to  []string
	str string
}

func initEmail(auth *email.GMail) {
	emailAuth = auth
	emailQueue = make(chan *email.Message, EMAIL_QUEUE_SIZE)
	msgs := []*email.Message{}
	recentlySent := util.NewAutoDecrementCounter(EMAIL_RATE_PERIOD)
	msgSep := strings.Repeat("=", 72)

	sendQueuedMessages := func() {
		// If there aren't any emails to send or we've exceeded our
		// emails-per-time-period limit, don't do anything.
		sent := recentlySent.Get()
		if len(msgs) == 0 || sent >= EMAIL_RATE_NUMBER {
			return
		}

		// Helper function for sending messages.
		sendMessage := func(msg *email.Message) {
			if emailAuth != nil {
				if err := emailAuth.SendMessage(msg); err != nil {
					glog.Errorf("Failed to send email: %s", err)
				}
			} else {
				glog.Errorf("Email auth is nil! Cannot send email!")
			}
			recentlySent.Inc()
		}

		// Send one or more messages.
		if sent >= EMAIL_RATE_NUMBER-1 && len(msgs) > 1 {
			// Special case: if we've almost hit our limit and there are multiple
			// emails to send, batch them into a "Multiple Alerts" email.

			// Aggregate the recipients and contents of the emails.
			recipients := map[string]bool{}
			body := ""
			for _, m := range msgs {
				for _, recipient := range m.To {
					recipients[recipient] = true
				}
				body += fmt.Sprintf("%s<br/><br/>%s<br/><br/>%s<br/><br/>", m.Subject, m.Body, msgSep)
			}
			to := make([]string, 0, len(recipients))
			for r, _ := range recipients {
				to = append(to, r)
			}
			sendMessage(&email.Message{
				To:      to,
				Subject: fmt.Sprintf("Skia Alerts: Multiple messages as of %s", time.Now()),
				Body:    body,
			})
		} else {
			// Send all queued messages.
			for _, m := range msgs {
				sendMessage(m)
			}
		}
		// Reset the queue.
		msgs = []*email.Message{}
	}

	go func() {
		for {
			select {
			case m := <-emailQueue:
				msgs = append(msgs, m)
			case <-time.Tick(time.Second):
				sendQueuedMessages()
			}
		}
	}()
}

// Create an email subject line from an Alert.
func (a *EmailAction) emailSubject(alert *Alert) string {
	return fmt.Sprintf(EMAIL_SUBJECT_TMPL, alert.Name, time.Unix(alert.Triggered, 0).String())
}

func (a *EmailAction) Fire(alert *Alert) {
	emailQueue <- &email.Message{
		To:      a.to,
		Subject: a.emailSubject(alert),
		Body:    alert.Message + EMAIL_FOOTER,
	}
}

func (a *EmailAction) Followup(alert *Alert, msg string) {
	emailQueue <- &email.Message{
		To:      a.to,
		Subject: a.emailSubject(alert),
		Body:    msg,
	}
}

func (a *EmailAction) String() string {
	return a.str
}

func NewEmailAction(to []string, str string) Action {
	return &EmailAction{
		to:  to,
		str: str,
	}
}

type PrintAction struct{}

func (a *PrintAction) Fire(alert *Alert) {
	glog.Infof("ALERT FIRED (%s): %s", alert.Name, alert.Message)
}

func (a *PrintAction) Followup(alert *Alert, msg string) {
	glog.Infof("ALERT FOLLOWUP (%s): %s", alert.Name, msg)
}

func (a *PrintAction) String() string {
	return "Print"
}

func NewPrintAction() Action {
	return &PrintAction{}
}

func parseEmailList(str string) []string {
	split := strings.Split(str, ",")
	emails := []string{}
	for _, email := range split {
		emails = append(emails, strings.Trim(email, " "))
	}
	return emails
}

// ParseAction converts a string to an Action.
func ParseAction(str string) (Action, error) {
	if strings.HasPrefix(str, "Email(") && strings.HasSuffix(str, ")") {
		to := parseEmailList(str[6 : len(str)-1])
		return NewEmailAction(to, str), nil
	} else if str == "Print" {
		return NewPrintAction(), nil
	} else {
		return nil, fmt.Errorf("Unknown action: %q", str)
	}

}

// ParseActions parses configuration information to produce Actions for an Alert.
func ParseActions(actions []string) ([]Action, error) {
	actionsList := []Action{}
	for _, actionString := range actions {
		action, err := ParseAction(actionString)
		if err != nil {
			return nil, fmt.Errorf("Failed to parse action: %v", err)
		}
		actionsList = append(actionsList, action)
	}
	return actionsList, nil
}
