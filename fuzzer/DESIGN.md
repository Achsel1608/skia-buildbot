Purpose of the Skia Fuzzer
==========================

Chrome has a fuzzer called [ClusterFuzz](https://www.chromium.org/Home/chromium-security/bugs/using-clusterfuzz)
that randomly bombards various components with input in an effort to find bugs.
Because inputs are randomly generated, the main bugs that can be found are a set of inputs that
crash Chrome.

Some of the bugs ClusterFuzz finds are in Skia.
We would like to find these bugs before ClusterFuzz does and find bugs in APIs that are not used by
Chrome using more focused tests than are possible with ClusterFuzz.

Fuzzes
------

A **fuzz** is some form of random input into Skia.
There are two categories of fuzzes: binary and API.

A **binary fuzz** is a randomly generated or mutated file that Skia imports/parses or loads.
Binary fuzzes would be of types `.skp`, `.png`, `.gif`, to name a few.
Binary fuzzes can be generated very efficiently and tested effectively using a tool called
[afl-fuzz](http://lcamtuf.coredump.cx/afl/).

An **API fuzz** is a randomly generated program that exercises the public APIs of SKIA.
The inputs to the API functions will be randomly generated and the order can be randomly determined,
given some parameters.
API fuzzes will likely need to be crafted with some human inputs to guide the overall creation.

We are not so much interested in the graphical output of a fuzz, but rather whether the fuzz caused
Skia to crash or not.
A fuzz that induces a crash is called a **bad fuzz**.
Once Skia has been patched and a bad fuzz no longer crashes Skia, that fuzz is then called a
**grey fuzz**.

Fuzzes will be named by a SHA1 hash of their contents, i.e. the input itself.
A fuzz's name will not change after it is created.

Design of the Skia Fuzzer
=========================

The fuzzer will consist of several mostly independent components:

1. **Generators** - Continuously creates and tests fuzzes against Skia.
2. **Aggregator** - Keeps track of bad fuzzes and uploads metrics about them to Google Storage.
3. **Sanitizer** - Periodically cleans out old grey fuzzes.
4. **Web front end** - Allows a user to browse all randomized programs, quickly find those that are
failing, and mark them as fixed.
5. **Fuzz trybot** - Allows a developer to execute the list of bad and/or grey fuzzes against their
code.


Generators
----------

Generators will continuously generate random fuzzes and execute them against Skia to see if they
cause a crash (i.e. are bad fuzzes).
There will be at least two Generators, one for binary fuzzes and one for API fuzzes.
Likely, there will be several of each type for various binary types and various portions of the API.

###Binary Fuzz Generators###

As mentioned before, [afl-fuzz](http://lcamtuf.coredump.cx/afl/) is a fantastic tool for creating
and testing binary fuzzes.
As an input, afl-fuzz takes some sample binary files (the smaller and faster to parse, i.e. < 100kb
and < 500ms, the better), the Skia source code, and a small runner program that loads the binary
file, in our case, [dm](https://github.com/google/skia/blob/master/dm/DM.cpp).
The runner program will be built as Release.
Afl-fuzz builds Skia with some specialized code, similar to a code coverage tool.
This allows afl-fuzz to find bad fuzzes that crash in different ways, rather than a naive solution
 which may find thousands of bad fuzzes that all exercise the same bug.

A binary fuzz generator using afl-fuzz would simply run afl-fuzz on as many cores as possible.
These afl-fuzz process will dump their results to disk, where the aggregator will scan to detect
new ones (see below).
When a new version of Skia is "under fuzz", all afl-fuzz seeds will be reset for a fresh analysis.
One level alert is "Last time a new binary fuzz found".


###API Fuzz Generators###

API Fuzz Generators will take a series of rules and create valid c++ programs which exercise the
Skia API.
For example, a rule might be to create random SkPaths and then try to draw it as a bitmap.


This is in the early phases of development, although some work has been done to parse the Skia AST
(generated by clang) and look at the Android JNI layer to Skia
([example](http://developer.android.com/reference/android/graphics/Path.html)) to automatically
determine the public-facing Skia API.
Additionally, this AST parsing allows automatic creation and dependency management.

An API fuzz generator will simply generate fuzzes using a set of rules on as many cores as possible
and let the aggregator pick up any bad fuzzes generated.

When a new version of Skia is set to be fuzzed, all previous bad and grey fuzzes will be re-compiled
and re-executed.
If the old fuzzes don't compile because of an API change, they will be deleted/retired by the
Sanitizer.

Stretch goal: Keep the random seeds that generated the old, non-compiling bad fuzzes so that it can
be regenerated using the new source code.


Aggregator
----------
The aggregator will find new bad fuzzes, create some metadata for them and upload fuzz and metadata
to Google Storage.
One aggregator will run on every vm that is running a generator.

Every time it triggers, say, once per minute, it will find new fuzzes and run them against a debug
and a release version of Skia, recording what happens as some metadata.
These two versions will be built off of the same Skia commit as was used in the Generator.
This metadata will include if either version crashed, if some assertions were broken, if a hang was
detected, etc.

The aggregator will upload the bad fuzzes and the metadata to Google Storage.


Sanitizer
---------
In the event the storage requirement becomes too large on Google Storage, we can use a sanitizer to
trim that down.
The sanitizer will periodically purge grey fuzzes from Google Storage older than some threshold.
The sanitizer will also be in charge of deleting API fuzzes that are obsolete (e.g. test code that
has been removed/deprecated).

Care will be taken to keep some of the older ones to easily detect regressions.
For example, if there are 600 old grey fuzzes with the same stack trace, the sanitizer might delete
all but a few of these.

The sanitizer functionality could be implemented as part of the Web Front End.

Web Front End
-------------

Skia developers should be able to visually browse the history of the fuzzer and
get quick access to any failing fuzzes.
The front end will have the ability to filter fuzzes by file, function and line number.

The go web server will periodically:
1.  Pull the fuzz details from Google Storage.
2.  Convert the fuzz details into an intermediate form in memory.  This intermediate form will be
tree-like, which makes "querying" it easier.

When web clients make a request for fuzzes by file, function, or line, the web server will slice
off a piece of the intermediate tree, convert it to JSON and return to be rendered.

Fuzz Try Bot
------------

If a developer is working on turning bad fuzzes into grey fuzzes, they may want to test their
pre-committed or committed code against a series of bad fuzzes.
The fuzz try bot will do exactly that.

There will likely be several settings for the trybots - run all bad fuzzes found this week, run all
regressing fuzzes, run all bad and grey fuzzes from the last 3 months, run all bad and grey fuzzes
from all time, etc.


Other Design Details
--------------------
All components will be run on GCE.

Execution against HEAD doesn't really make much sense because fuzzing takes some time to get good
coverage (especially afl-fuzz).
To account for this, Skia will be pulled from the latest Blink DEPS roll every week for fuzzing,
unless a developer requests a fresh pull (e.g. after fixing some broken code and executing the fuzz
trybot).