<!--
  The common.js file must be included before this file.

  This in an HTML Import-able file that contains the definition
  of the following elements:

    <commits-sk>

  To use this file import it:

    <link href="/res/imp/commits-sk.html" rel="import" />

  Usage:

    <commits-sk></commits-sk>

  Properties:
    builderFilter: Which builders to show. One of:
        [hide, interesting, failures, all]
    reload: How often (in seconds) to reload alert data.
    repo: Name of the repository.

  Methods:
    setAutoRollStatus(status): Update the commits-sk with the status of
        the AutoRoll Bot, which will be incorporated into the repo
        graph. The currentRollRevision and lastRollRevision parameters
        are expected to be valid commit hashes.
-->
<polymer-element name="commits-sk">
  <template>
    <style>
    #commitCanvas {
      width: 0px;
      height: 0px;
    }
    table.commitList {
      border: 0px;
      border-spacing: 0px;
      width: 100%;
    }
    th {
      text-align: left;
      white-space: nowrap;
      font-size: 12px;
    }
    th.header {
      height: 53px;
      padding: 5px;
    }
    th.category {
      border-top-left-radius: 5px;
      border-top-right-radius: 5px;
      border-style: solid;
      border-left-width: 1px;
      border-top-width: 1px;
      border-right-width: 0px;
      border-bottom-width: 0px;
      font-size: 12px;
      height: 17px;
      text-align: center;
      overflow: hidden;
    }
    th.category:last-child {
      border-right-width: 1px;
    }
    th.category:empty {
      border-width: 1px 0px 0px 0px;
      border-color: #FFFFFF;
    }
    th.subcategory {
      background-color: #EFEFEF;
      border-top-left-radius: 5px;
      border-top-right-radius: 5px;
      border-style: solid;
      border-left-width: 1px;
      border-top-width: 1px;
      border-right-width: 0px;
      border-bottom-width: 0px;
      font-size: 10px;
      height: 14px;
      text-align: center;
      overflow: hidden;
    }
    th.subcategory:last-child {
      border-right-width: 1px;
    }
    th.subcategory:empty {
      background-color: #FFFFFF;
      border-width: 1px 0px 0px 0px;
      border-color: #FFFFFF;
    }
    tr.builder {
      height: 24px;
    }
    tr.commit {
      font-size: 10px;
      font-family: monospace;
      height: 20px;
      margin: 0px;
      padding: 0px;
    }
    .alt:nth-child(even) {
      background-color: #EFEFEF;
    }
    .alt:nth-child(odd) {
      background-color: #FFFFFF;
    }
    td {
      padding: 0px;
      margin: 0px;
      white-space: nowrap;
    }
    td.author {
      width: {{authorWidth}}px;
      min-width: {{authorWidth}}px;
      max-width: {{authorWidth}}px;
      text-overflow: ellipses;
    }
    td.build {
      text-align: center;
      padding: 0px;
      width: {{builderWidth}}px;
      max-width: {{builderWidth}}px;
      min-width: {{builderWidth}}px;
    }
    td.commentIndicator {
      width: {{commentIndicatorWidth}}px;
      max-width: {{commentIndicatorWidth}}px;
      min-width: {{commentIndicatorWidth}}px;
    }
    td.revertIndicator {
      width: {{revertIndicatorWidth}}px;
      max-width: {{revertIndicatorWidth}}px;
      min-width: {{revertIndicatorWidth}}px;
    }
    a {
      color: inherit;
      position: relative;
      z-index: 2;
    }
    a.author {
      text-decoration: none;
    }
    a.author:hover {
      text-decoration: underline;
    }
    a.build {
      border-style: solid;
      border-color: gray;
      display: block;
    }
    a.build_single {
      border-width: 1px;
      border-radius: 3px;
      margin: 1px 0px 1px 1px;
      height: 16px;
    }
    a.build_middle {
      border-width: 0px 1px;
      border-radius: 0px;
      margin: 0px 0px 0px 1px;
      height: 20px;
    }
    a.build_top {
      border-width: 1px 1px 0px 1px;
      border-top-left-radius: 3px;
      border-top-right-radius: 3px;
      margin: 1px 0px 0px 1px;
      height: 18px;
    }
    a.build_bottom {
      border-width: 0px 1px 1px 1px;
      border-bottom-left-radius: 3px;
      border-bottom-right-radius: 3px;
      margin: 0px 0px 1px 1px;
      height: 18px;
    }
    a.builder {
      background-color: white;
      height: 20px;
      margin: 0px;
    }
    paper-shadow.builder {
      border-radius: 3px;
    }
    core-icon.tiny {
      width: 12px;
      height: 12px;
    }
    core-icon[icon="undo"] {
      color: #D95F02;
    }
    #buildbotSelector > paper-radio-button {
      padding-right: 12px;
    }
    paper-radio-group::shadow ::content > * {
      padding: 2px;
    }
    paper-radio-button::shadow #ink {
      top: 0px;
      left: 0px;
      width: 16px;
      height: 16px;
    }
    div.commitHighlight {
      position: absolute;
      top: -16px;
      left: -{{canvasWidth}}px;
      width: {{windowWidth}}px;
      height: 19px;
      border: 1px solid red;
      z-index: 1;
    }
    .authorText {
      position: relative;
      z-index: 2;
    }
    </style>
    <url-param-sk name="commitLabel" value="{{commitLabel}}" valid="{{validCommitLabels}}"></url-param-sk>
    <url-param-sk name="filter" value="{{builderFilter}}" valid="{{validFilters}}"></url-param-sk>
    <url-param-sk name="search" value="{{builderSearch}}"></url-param-sk>
    <div id="container">
      <div horizontal layout flex>
        <div>
          <!-- Use another as a spacer for the canvas. I couldn't find a sane
               way to put the canvas in the same table as the commit data. -->
          <table class="commitList">
            <thead>
              <tr>
                <th class="header" style="font-size: 0.7em; font-weight: normal;">
                  <nobr>Reload (s):
                  <paper-input type="number" value="{{reload}}" preventInvalidInput style="width: 50px;"></paper-input></nobr>
                  <br/>
                  Loaded {{lastLoaded}}
                </th>
              </tr>
              <template if="{{numBuilders > 0}}">
                <tr><th class="category"></th></tr>
                <tr><th class="subcategory"></th></tr>
                <tr class="builder"><td></td></tr>
              </template>
            </thead>
            <tbody>
              <tr class="commit">
                <td>
                  <canvas id="commitCanvas"></canvas>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
        <div flex>
          <table class="commitList">
            <thead>
              <tr>
                <th class="header" colspan="3">
                  <paper-radio-group id="commitLabelSelector" selected="{{commitLabel}}">
                    <template repeat="{{label in validCommitLabels}}">
                      <paper-radio-button name="{{label}}" label="{{commitLabels[label]}}"></paper-radio-button><br/>
                    </template>
                  </paper-radio-group>
                </th>
                <th class="header" colspan="{{numBuilders}}">
                  <paper-radio-group id="buildbotSelector" selected="{{builderFilter}}">
                    <template repeat="{{filter in validFilters}}">
                    <paper-radio-button name="{{filter}}" label="{{filters[filter]}}"></paper-radio-button>
                    </template>
                  </paper-radio-group>
                  <paper-input
                      id="builderTextFilter"
                      value="{{builderSearch}}"
                      label="Search"
                      on-change="{{setFilterToSearch}}">
                  </paper-input>
                </th>
                <th class="header"><!-- Commit message --></th>
              </tr>
              <template if="{{numBuilders > 0}}">
                <tr>
                  <td colspan="3" rowspan="3" style="font-size: 10px;">
                    <core-icon class="tiny" icon="communication:chat"></core-icon> comment<br/>
                    <core-icon class="tiny" icon="image:texture"></core-icon> flaky<br/>
                    <core-icon class="tiny" icon="block"></core-icon> ignore failure<br/>
                    <core-icon class="tiny" icon="undo"></core-icon> reverted<br/>
                  </td>
                  <template repeat="{{c in builderCategoryList}}">
                    <th class="category" colspan="{{builderCategories[c].colspan}}" style="width: {{builderCategories[c].colspan * builderWidth}}px; max-width: {{builderCategories[c].colspan * builderWidth}}px; min-width: {{builderCategories[c].colspan * builderWidth}}px;">{{c}}</th>
                  </template>
                </tr>
                <tr>
                  <template repeat="{{c in builderCategoryList}}">
                    <template repeat="{{s in builderCategories[c].subcategoryList}}">
                      <th class="subcategory" colspan="{{builderCategories[c].subcategories[s].builders.length}}" style="width:{{builderCategories[c].subcategories[s].builders.length * builderWidth}}px; min-width:{{builderCategories[c].subcategories[s].builders.length * builderWidth}}px; max-width:{{builderCategories[c].subcategories[s].builders.length * builderWidth}}px;">{{s}}</th>
                    </template>
                  </template>
                </tr>
                <tr class="builder">
                  <template repeat="{{c in builderCategoryList}}">
                    <template repeat="{{s in builderCategories[c].subcategoryList}}">
                      <template repeat="{{b in builderCategories[c].subcategories[s].builders}}">
                        <td class="build" title="{{b}}">
                          <paper-shadow z="1" class="builder">
                          <a id="openBuilder|{{b}}" class="builder build build_single" href="#" onClick="return false;" on-click="{{openBuilderPopup}}">
                            <template if="{{allBuilders[b].ignoreFailure}}">
                              <core-icon class="tiny" icon="block" alt="Failures on this builder are ignored."></core-icon>
                            </template>
                            <template if="{{allBuilders[b].flaky}}">
                              <core-icon class="tiny" icon="image:texture" alt="This builder is marked as flaky."></core-icon>
                            </template>
                            <template if="{{allBuilders[b].comments.length > 0}}">
                              <core-icon class="tiny" icon="communication:chat" alt="This builder has a comment."></core-icon>
                            </template>
                          </a>
                          </paper-shadow>
                        </td>
                      </template>
                    </template>
                  </template>
                </tr>
              </template>
            </thead>
            <tbody>
              <template repeat="{{commit, i in commits}}">
                <tr class="commit alt">
                  <td class="author" id="{{commit.hash}}-author-td" title="{{commit.subject|shortSubject}}">
                    <a id="opencommit|{{i}}" href="#" class="author" onClick="return false;" on-click="{{openCommitPopup}}">
                      <span class="authorText" style="display: {{commitLabel == 'author' ? 'block' : 'none'}}">
                        {{commit.author|shortAuthor}}
                      </span>
                      <span class="authorText" style="display: {{commitLabel == 'author' ? 'none' : 'block'}}">
                        {{commit.subject|shortSubject}}
                      </span>
                    </a>
                    <span style="position: relative; display: block;">
                      <template if="{{commit.hash|shouldHighlight}}">
                        <div class="commitHighlight"></div>
                      </template>
                    </span>
                  </td>
                  <td class="commentIndicator">
                    <template if="{{commit.comments && commit.comments.length > 0}}">
                      <a id="opencommit|{{i}}" href="#" class="author" onClick="return false;" on-click="{{openCommitPopup}}">
                        <core-icon class="tiny" icon="communication:chat" alt="There are comments on this commit."></core-icon>
                      </a>
                    </template>
                  </td>
                  <td class="revertIndicator">
                    <template if="{{revertedHashToReverter[commit.hash]}}">
                      <a id="{{commit.hash}}" href="#" class="author" onClick="return false;" on-click="{{toggleReverter}}">
                        <core-icon class="tiny" icon="undo" alt="This commit has been reverted."></core-icon>
                      </a>
                    </template>
                  </td>
                  <template repeat="{{c in builderCategoryList}}">
                    <template repeat="{{s in builderCategories[c].subcategoryList}}">
                      <template repeat="{{builder in builderCategories[c].subcategories[s].builders}}">
                        <td class="build">
                          <template if="{{buildDetails[commit.hash][builder]}}">
                            <a id="openbuild|{{commit.hash}}|{{builder}}"
                               href="#"
                               class="build {{commit.displayClass[builder]}}"
                               onClick="return false;"
                               on-click="{{openBuildPopup}}"
                               style="background-color: {{buildDetails[commit.hash][builder].color}};"
                               title="{{builder}}, #{{buildDetails[commit.hash][builder].number}}"
                              >
                              <template if="{{buildDetails[commit.hash][builder].comments && buildDetails[commit.hash][builder].comments.length > 0 && (commit.displayClass[builder] == 'build_top' || commit.displayClass[builder] == 'build_single')}}">
                                <core-icon class="tiny" icon="communication:chat" alt="There are comments on this build." style="margin-top: 5px;"></core-icon>
                              </template>
                            </a>
                          </template>
                        </td>
                      </template>
                    </template>
                  </template>
                </tr>
              </template>
            </tbody>
          </table>
        </div>
      </div>
      <div horizontal center-justified layout>
        <paper-spinner id="loading" active></paper-spinner>
      </div>
      <paper-dialog id="infoDialog"></paper-dialog>
    </div>
  </template>
  <script>
  (function() {
    var defaultCommitsToLoad = 35; // Default number of commits to load.
    var commitY = 20;              // Vertical pixels used by each commit.
    var paddingX = 10;             // Left-side padding pixels.
    var paddingY = 20;             // Top padding pixels.
    var radius = 3;                // Radius of commit dots.
    var columnWidth = commitY;     // Pixel width of per-branch colums.
    // Colors used for the branches. Obtained from
    // http://blog.mollietaylor.com/2012/10/color-blindness-and-palette-choice.html
    var palette = [
      "#1B9E77", // Blue/green
      "#D95F02", // Red/orange
      "#7570B3", // Purple
      "#E7298A", // Pink
      "#66A61E", // Light green
      "#E6AB02", // Light orange
      "#A6761D", // Brown
      "#666666", // Gray
    ];
    var commitBg = "#FFFFFF";    // Background color of alternating commits.
    var commitBgAlt = "#EFEFEF"; // Background color of alternating commits.
    var font = "10px monospace"; // Font used for labels.

    // Draws a filled-in dot at the given center with the given radius and color.
    function drawDot(ctx, center, radius, color) {
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(center.x, center.y, radius, 0, 2*Math.PI, false);
      ctx.fill();
      ctx.closePath();
    }

    // Object with an x and y-value.
    function Point(x, y) {
      this.x = x;
      this.y = y;
    }

    // Truncate the given string to the given length. If the string was
    // shortened, change the last three characters to ellipsis.
    function truncate(str, len) {
      if (str.length > len) {
        var ellipsis = "..."
        return str.substring(0, len - ellipsis.length) + ellipsis;
      }
      return str
    }

    // Object representing a commit used for creating layout and drawing.
    function Commit(commitInfo, row) {
      this.hash = commitInfo.hash;
      this.author = commitInfo.author;
      this.subject = commitInfo.subject;
      this.timestamp = new Date(commitInfo.timestamp);
      this.row = row;
      this.column = -1;
      this.label = [];
      this.parents = commitInfo.parent;

      // The color for this commit.
      this.color = function() {
        return palette[this.column % palette.length];
      };

      // Where to draw this commit.
      this.getBounds = function() {
        return new Point(paddingX, paddingY - commitY/4 + commitY * this.row);
      };

      // The center of this commit's dot.
      this.dotCenter = function() {
        var start = this.getBounds();
        var centerX = start.x + columnWidth * this.column + radius;
        var centerY = start.y - radius - 2;
        return new Point(centerX, centerY);
      };

      // Coordinates for drawing this commit's label.
      this.labelCoords = function() {
        var bounds = this.getBounds();
        var center = this.dotCenter();
        return new Point(center.x + 3 * radius, bounds.y - 1);
      };

      // Return the text for this commit's label, truncated to 24 characters.
      this.labelText = function() {
        return truncate(this.label.join(","), 24);
      };

      // Return the estimated width of this commit's label text.
      this.labelWidth = function(ctx) {
        return ctx.measureText(this.labelText()).width;
      };

      // Draw an an alternating background color for this commit.
      this.drawBackground = function(ctx) {
        var startY = commitY * this.row;
        var bgColor = this.row % 2 ? commitBg : commitBgAlt;
        ctx.fillStyle = bgColor;
        ctx.fillRect(0, startY, ctx.canvas.clientWidth, startY + commitY);
      };

      // Draw a line connecting this commit to one of its parents.
      this.drawConnection = function(ctx, parent, allCommits) {
        var center = this.dotCenter();
        var to = parent.dotCenter();
        ctx.beginPath();
        ctx.moveTo(center.x, center.y);
        if (this.column == parent.column) {
          // Draw a straight line.
          ctx.lineTo(to.x, to.y);
        } else {
          // Draw a connector composed of five segments: a vertical line, an
          // arc, a horizontal line, another arc, and another vertical line.
          // One or more of the lines may have zero length.
          var arcRadius = commitY / 2;
          // The direction in which to draw the arc.
          var d = center.x > to.x ? 1 : -1;

          // We'll reuse these values, so pre-compute them.
          var halfPI = 0.5 * Math.PI;
          var oneAndHalfPI = 1.5 * Math.PI;

          // If there is at least one commit in the current commit's column
          // between the current commit and this parent, the first arc must
          // begin at the current commit: the first vertical line has zero
          // length. Otherwise, the length of the first vertical line is
          // flexible.
          var v1_flex = true;
          for (var i = 0; i < this.parents.length; i++) {
            var c = allCommits[this.parents[i]];
            if (this.timestamp > c.timestamp && c.timestamp > parent.timestamp) {
              if (this.column == c.column) {
                v1_flex = false;
                break;
              }
            }
          }

          // If there is at least one commit in the parent's column between the
          // current commit and this parent, the secon arc must end at the
          // parent commit: the second vertical line has zero length.
          // Otherwise, the length of the second vertical line is flexible.
          var v2_flex = true;
          for (var i = 0; i < parent.children.length; i++) {
            var c = allCommits[parent.children[i]];
            if (this.timestamp > c.timestamp && c.timestamp > parent.timestamp) {
              if (parent.column == c.column) {
                v2_flex = false;
                break;
              }
            }
          }

          // Arc information..
          var a1 = new Point(center.x - d * arcRadius, to.y - commitY);
          var a2 = new Point(to.x + d * arcRadius, to.y);

          // If both vertical lines are flexible, arbitrarily choose where to
          // put the arcs and horizontal line (eg. next to the parent).
          if (v1_flex && v2_flex) {
            a1.y = to.y - commitY;
            a2.y = to.y;
          }
          // If exactly one vertical line is flexible, put the arcs and
          // horizontal line where they must go.
          else if (v1_flex && !v2_flex) {
            a1.y = to.y - commitY;
            a2.y = to.y;
          } else if (!v1_flex && v2_flex) {
            a1.y = center.y;
            a2.y = center.y + commitY;
          }
          // If neither vertical line is flexible, then we have to place arcs
          // at both commits and the "horizontal" line becomes diagonal.
          else {
            a1.y = center.y;
            a2.y = to.y;
          }

          // Distance between the two arc centers.
          var dist = Math.sqrt(Math.pow(a2.x - a1.x, 2) + Math.pow(a2.y - a1.y, 2));
          // Length of the arc to draw.
          var arcLength = Math.PI - Math.acos(2*arcRadius / dist) - Math.acos((Math.abs(to.x - center.x) - 2*arcRadius) / dist);
          var a1_start = halfPI - d * halfPI;
          var a2_start = oneAndHalfPI - d * (halfPI - arcLength);

          // Draw the connector: vertical line, arc, horizontal line, arc,
          // vertical line.
          ctx.lineTo(a1.x + d*arcRadius, a1.y);
          ctx.arc(a1.x, a1.y, arcRadius, a1_start, a1_start + d*arcLength, d < 0);
          // The middle line doesn't need to be explicitly drawn.
          ctx.arc(a2.x, a2.y, arcRadius, a2_start, a2_start - d*arcLength, d > 0);
          ctx.lineTo(to.x, to.y);
        }
        ctx.strokeStyle = this.color();
        ctx.stroke();
      };

      // Draw this commit's label.
      this.drawLabel = function(ctx) {
        if (this.label.length <= 0) {
          return;
        }
        labelCoords = this.labelCoords();
        var w = this.labelWidth(ctx);
        var h = parseInt(font);
        var paddingY = 3;
        var paddingX = 3;
        ctx.fillStyle = this.color();
        ctx.fillRect(labelCoords.x - paddingX, labelCoords.y - h, w + 2 * paddingX, h + paddingY);
        ctx.fillStyle = "#FFFFFF";
        ctx.fillText(this.labelText(), labelCoords.x, labelCoords.y);
      };

      this.draw = function(ctx, displayCommits) {
        var color = this.color();
        var center = this.dotCenter();

        // Connect the dots.
        for (var p = 0; p < this.parents.length; p++) {
          var parent = displayCommits[this.parents[p]];
          this.drawConnection(ctx, parent, displayCommits);
        }

        // Draw a dot.
        drawDot(ctx, center, radius, color);

        // Draw a label, if applicable.
        this.drawLabel(ctx);
      };
    }

    // Follow commits by first parent, assigning the given column until we get
    // to a commit that we aren't going to draw.
    function traceCommits(displayCommits, commits, remaining, hash, column) {
      var usedColumn = false;
      while(remaining[hash]) {
        var c = displayCommits[hash];
        c.column = column;
        delete remaining[hash];
        hash = c.parents[0];
        usedColumn = true;
        // Special case for non-displayed parents.
        if (!displayCommits[hash]) {
          var parent = new Commit({
            hash: hash,
          }, commits.length);
          parent.column = c.column;
          displayCommits[hash] = parent;
        }
      }
      return usedColumn;
    }

    // Create Commit objects to be displayed. Assigns rows and columns for each
    // commit to assist in producing a nice layout.
    function prepareCommitsForDisplay(commits, branchHeads) {
      // Create a Commit object for each commit.
      var displayCommits = {}; // Commit objects by hash.
      var remaining = {};      // Not-yet-processed commits by hash.
      for (var i = 0; i < commits.length; i++) {
        var c = new Commit(commits[i], i)
        displayCommits[c.hash] = c;
        remaining[c.hash] = c;
      }

      // Pre-process the branches. We want master first, and no HEAD.
      var masterIdx = -1;
      var branches = [];
      for (var b = 0; b < branchHeads.length; b++) {
        if (branchHeads[b].name == "master") {
          masterIdx = b;
          branches.push(branchHeads[b]);
        }
      }
      for (var b = 0; b < branchHeads.length; b++) {
        var branch = branchHeads[b];
        if (b != masterIdx && branch.name != "HEAD") {
          branches.push(branch);
        }
      }

      // Trace each branch, placing commits on that branch in an associated column.
      var column = 0;
      for (var b = 0; b < branches.length; b++) {
        // Add a label to commits at branch heads.
        var hash = branches[b].head
        // The branch might have scrolled out of the time window. If so, just
        // skip it.
        if (!displayCommits[hash]) {
          continue
        }
        displayCommits[hash].label.push(branches[b].name);
        if (traceCommits(displayCommits, commits, remaining, hash, column)) {
          column++;
        }
      }

      // Add the remaining commits to their own columns.
      for (var hash in remaining) {
        if (traceCommits(displayCommits, commits, remaining, hash, column)) {
          column++;
        }
      }

      // Point all parents at their children, for convenience.
      for (var hash in displayCommits) {
        displayCommits[hash].children = [];
      }
      for (var hash in displayCommits) {
        var c = displayCommits[hash];
        if (c.parents) {
          for (var i = 0; i < c.parents.length; i++) {
            displayCommits[c.parents[i]].children.push(c.hash);
          }
        }
      }

      return [displayCommits, column];
    }

    Polymer({
      publish: {
        reload: {
          value: 60,
          reflect: true,
        },
        repo: {
          value: "skia",
          reflect: true,
        },
        builderFilter: {
          value: "interesting",
          reflect: true,
        },
      },

      created: function() {
        var params = sk.query.toParamSet(window.location.search.split("?")[1]);
        this.allBuilders = {};
        this.autorollCurrent = null;
        this.autorollLast = null;
        this.branchHeads = [];
        this.buildbotUrlPrefix = "https://build.chromium.org/p";
        this.builderCategories = {};
        this.builderCategoryList = [];
        this.builderSearchChangedTimeout = null;
        this.builderWidth = "5px";
        this.builds = {};
        this.buildDetails = {};
        this.buildTableWidth = 0;
        this.canvasWidth = 0;
        this.canvasHeight = 0;
        this.cellWidthAuthor = 100;
        this.cellWidthSubject = 440;
        this.commentIndicatorWidth = 14;
        this.commits = [];
        this.displayCommits = {};
        this.highlightedCommits = params["commit"] || [];
        this.lastLoaded = "(not yet loaded)";
        this.numBuilders = 0;
        this.minCanvasWidth = 120;
        this.revertedHashToReverter = {};
        this.revertIndicatorWidth = 14;
        this.showSubject = false;
        this.timeout = null;
        this.windowHeight = 0;
        this.windowWidth = 0;

        this.authorWidth = this.cellWidthAuthor;

        // Builder filters.
        this.filters = {
          "interesting": "Interesting",
          "failures": "Failures",
          "comments": "Comments",
          "nocomment": "Failing w/o comment",
          "all": "All",
          "search": " ",
        };
        this.validFilters = Object.keys(this.filters);
        this.builderSearch = "";

        // Commit labels.
        this.commitLabels = {
          "author": "Author",
          "subject": "Subject",
        };
        this.validCommitLabels = Object.keys(this.commitLabels);
        this.commitLabel = this.validCommitLabels[0];

        var that = this;
        sk.Login.then(function(status) {
          var email = status['Email'];
          var validEmail = "@google.com"
          if (email.indexOf(validEmail, email.length - validEmail.length) !== -1) {
            that.buildbotUrlPrefix = "https://uberchromegw.corp.google.com/i";
          }
        });
        window.addEventListener("resize", function() {
          window.setTimeout(function() { that.draw(); }, 0);
        }, true);
      },

      ready: function() {
        this.reloadCommits();
      },

      commitLabelChanged: function() {
        if (this.commitLabel == "author") {
          this.authorWidth = this.cellWidthAuthor;
        } else {
          this.authorWidth = this.cellWidthSubject;
        }
        this.draw();
      },

      builderFilterChanged: function() {
        this.filterBuilders();
      },

      // setAutoRollStatus adds the AutoRoll Bot status to the commits graph.
      setAutoRollStatus: function(currentRollRevision, lastRollRevision) {
        this.autorollCurrent = currentRollRevision;
        this.autorollLast = lastRollRevision;
        this.draw();
      },

      // shortCommit returns the first 12 characters of a commit hash.
      shortCommit: function(commit) {
        return commit.substring(0, 12);
      },

      // shortAuthor shortens the commit author field by returning the
      // parenthesized email address if it exists. If it does not exist, the
      // entire author field is used.
      shortAuthor: function(author) {
        var re = /.*\((.+)\)/;
        var match = re.exec(author);
        var res = author;
        if (match) {
          res = match[1];
        }
        return res.split("@")[0];
      },

      // shortSubject truncates a commit subject line to 72 characters if needed.
      // If the text was shortened, the last three characters are replaced by
      // ellipsis.
      shortSubject: function(subject) {
        return truncate(subject, 72);
      },

      reloadChanged: function() {
        this.resetTimeout();
      },

      resetTimeout: function() {
        if (this.timeout) {
          window.clearTimeout(this.timeout);
        }
        if (this.reload > 0) {
          var that = this;
          this.timeout = window.setTimeout(function() {
            that.reloadCommits();
          }, this.reload * 1000);
        }
      },

      // Filter out green bots unless "showAllBuilders" is checked.
      filterBuilders: function() {
        console.time("filterBuilders");
        var filteredBuilders = [];
        var selected = this.builderFilter;
        if (selected == "all") {
          for (var builder in this.allBuilders) {
            filteredBuilders.push(builder);
          }
        } else if (selected == "interesting" || selected == "failures" || selected == "nocomment") {
          for (var builder in this.allBuilders) {
            var failed = false;
            var succeeded = false;
            for (var buildNum in this.builds[builder]) {
              var build = this.builds[builder][buildNum];
              if (!build.finished) {
                continue;
              }
              if (build.results == 0) {
                succeeded = true;
              } else {
                failed = true;
              }
              if (selected == "interesting") {
                if (succeeded && failed && !this.allBuilders[builder].ignoreFailure) {
                  filteredBuilders.push(builder);
                  break;
                }
              } else if (selected == "failures") {
                if (failed) {
                  filteredBuilders.push(builder);
                  break;
                }
              } else if (selected == "nocomment") {
                if (build.results != 0 && this.allBuilders[builder].comments.length == 0) {
                  if (!build.comments || build.comments.length == 0) {
                    filteredBuilders.push(builder);
                    break;
                  }
                }
              }
            }
          }
        } else if (selected == "comments") {
          for (var builder in this.allBuilders) {
            if (this.allBuilders[builder].comments.length > 0) {
              filteredBuilders.push(builder);
              continue;
            }
            for (var buildNum in this.builds[builder]) {
              var build = this.builds[builder][buildNum];
              if (!build.finished) {
                continue;
              }
              if (build.comments && build.comments.length > 0) {
                filteredBuilders.push(builder);
                break;
              }
            }
          }
        } else if (selected == "search") {
          var matchText = this.$.builderTextFilter.value;
          for (var builder in this.allBuilders) {
            if (builder.toLowerCase().match(matchText.toLowerCase())) {
              filteredBuilders.push(builder);
            }
          }
        } else {
          console.error("Invalid builder filter selection: " + selected);
        }
        sk.sortStrings(filteredBuilders);
        this.numBuilders = filteredBuilders.length;

        var categories = {};
        var categoryList = [];
        for (var i = 0; i < filteredBuilders.length; i++) {
          var builderName = filteredBuilders[i];
          var category = this.allBuilders[builderName].category;
          if (!category) {
            category = "Other";
          }
          if (!categories[category]) {
            categories[category] = {
              colspan: 0,
              subcategoryList: [],
              subcategories: {},
            };
            categoryList.push(category);
          }
          var subcategory = this.allBuilders[builderName].subcategory;
          if (!subcategory) {
            subcategory = "Other";
          }
          if (!categories[category].subcategories[subcategory]) {
            categories[category].subcategories[subcategory] = {
              builders: [],
            };
            categories[category].subcategoryList.push(subcategory);
          }
          categories[category].subcategories[subcategory].builders.push(builderName);
          categories[category].colspan++;
        }
        this.builderCategories = categories;
        this.builderCategoryList = categoryList;
        console.timeEnd("filterBuilders");
      },

      // Is the info popup open?
      infoPopupOpen: function() {
        return this.$.infoDialog.style.display != "none";
      },

      // Set the dialog content and open the dialog.
      openDialog: function(child) {
        this.$.infoDialog.innerHTML = "";
        var infoDialogContent = document.createElement("div");
        infoDialogContent.id = "infoDialogContent";
        infoDialogContent.style.width = this.windowWidth * 0.7 + "px";
        infoDialogContent.style.minWidth = this.windowWidth * 0.7 + "px";
        infoDialogContent.style.maxWidth = this.windowWidth * 0.7 + "px";
        infoDialogContent.style.height = this.windowHeight * 0.7 + "px";
        infoDialogContent.style.minHeight = this.windowHeight * 0.7 + "px";
        infoDialogContent.style.maxHeight = this.windowHeight * 0.7 + "px";
        infoDialogContent.appendChild(child);
        this.$.infoDialog.appendChild(infoDialogContent);
        this.$.infoDialog.toggle();
      },

      // Open the build popup.
      openBuildPopup: function(e, d, s) {
        if (this.infoPopupOpen()) {
          return;
        }
        var split = s.id.split("|");
        if (split.length != 3) {
          throw "Invalid id: " + s.id;
        }
        var commit = split[1];
        var builder = split[2];
        var build = this.buildDetails[commit][builder];
        if (build) {
          var buildInfo = document.createElement("build-popup-sk");
          buildInfo.build = build;
          buildInfo.buildbotUrlPrefix = this.buildbotUrlPrefix;
          buildInfo.repo = this.repo;
          this.openDialog(buildInfo);
        }
      },

      // Open the builder popup.
      openBuilderPopup: function(e, d, s) {
        if (this.infoPopupOpen()) {
          return;
        }
        var split = s.id.split("|");
        if (split.length != 2) {
          throw "Invalid id: " + s.id;
        }
        var builder = split[1];
        if (builder) {
          var builderInfo = document.createElement("builder-popup-sk");
          builderInfo.builder = this.allBuilders[builder];
          builderInfo.buildbotUrlPrefix = this.buildbotUrlPrefix;
          builderInfo.repo = this.repo;
          this.openDialog(builderInfo);
        }
      },

      // Open the commit popup.
      openCommitPopup: function(e, d, s) {
        if (this.infoPopupOpen()) {
          return;
        }
        var split = s.id.split("|");
        if (split.length != 2) {
          throw "Invalid id: " + s.id;
        }
        var commit = this.commits[split[1]];
        if (commit) {
          var commitInfo = document.createElement("commit-popup-sk");
          commitInfo.commit = commit;
          commitInfo.repo = this.repo;
          this.openDialog(commitInfo);
        }
      },

      // Toggle the highlighting of the reverting commit.
      toggleReverter: function(e, d, s) {
        var reverterHash = this.revertedHashToReverter[s.id];
        if (!reverterHash) {
          // Could not determine who the reverter was.
          return;
        }
        var elem = this.shadowRoot.getElementById(reverterHash + "-author-td");
        elem.style.backgroundColor = "#D95F02";
        this.openCommitPopup(e, d, elem.children[0]);
        this.$.infoDialog.addEventListener("core-overlay-close-completed", function(event) {
            // Remove the highlight when the dialog closes.
            elem.style.backgroundColor = "";
            event.target.removeEventListener(event.type, arguments.callee);
        });
      },

      // Find and return the codereview issue number.
      findIssueNumber: function(commit) {
        // If there are multiple Review URLs in a CL then it selects the last one.
        var re = /(.|[\r\n])*Review URL: https:\/\/codereview.chromium.org\/([0-9]*)/g;
        var tokens = re.exec(commit.body);
        if (tokens) {
          return tokens[tokens.length - 1];
        }
      },

      // Return whether this commit reverted another commit.
      isRevert: function(commit) {
        // Check to see if this is a revert CL. The subject of the CL needs to start with
        // "Revert ".
        var re = /^Revert /g;
        var tokens = re.exec(commit.subject);
        if (tokens) {
          return true;
        }
        return false;
      },

      // Find and return the hash of the reverted commit.
      findRevertedHash: function(commit) {
        var re = /(.|[\r\n])*\> Committed\: https\:\/\/skia\.googlesource\.com\/skia\/\+\/([a-z0-9]*)/g;
        var tokens = re.exec(commit.body);
        if (tokens) {
          return tokens[tokens.length - 1];
        }
      },

      // Reload the commits.
      reloadCommits: function() {
        console.log("Loading commits.");
        console.time("totalLoadTime");
        console.time("loadData");
        if (this.$) {
          this.$.loading.style.display = "block";
          this.$.loading.active = true;
        }
        var url = "/json/" + this.repo + "/commits/?n=" + defaultCommitsToLoad;
        console.log("GET " + url);
        var that = this;
        sk.get(url).then(JSON.parse).then(function(json) {
          console.timeEnd("loadData");
          console.time("processData");
          json.commits.reverse();
          for (var i = 0; i < json.commits.length; i++) {
            json.commits[i].comments = json.comments[json.commits[i].hash] || [];
          }
          that.lastLoaded = new Date().toLocaleTimeString();

          var commits = json.commits;

          // Prepare build data.
          console.log("Preparing build data.");
          var builds = {};
          var builders = {};
          var buildDetails = that.buildDetails;
          for (var k in json.builds) {
            buildDetails[k] = json.builds[k];
          }

          for (var i = 0; i < commits.length; i++) {
            var commit = commits[i];
            commit.issue = that.findIssueNumber(commit);
            commit.isRevert = that.isRevert(commit);
            if (commit.isRevert) {
                that.revertedHashToReverter[that.findRevertedHash(commit)] = commit.hash;
            }
            commit.displayClass = {};
            for (var builder in buildDetails[commit.hash]) {
              var build = buildDetails[commit.hash][builder];
              if (!build.finished) {
                build.color = "rgba(230, 171, 2, 0.0)";
              } else if (build.results == 0 || build.results == 1 || build.results == 3) {
                build.color = "rgba(102, 166, 30, 0.3)";
              } else if (build.results == 2) {
                build.color = "#D95F02";
              } else if (build.results == 4 || build.results == 5) {
                build.color = "#7570B3";
              }
              if (!builds[builder]) {
                // This is the first time we've seen this builder.
                builds[builder] = {};
                var builderDetails = {
                    "comments": json.builders[builder] || [],
                    "builder": builder,
                    "master": build.master,
                    // We're traveling backward in time, so the first build we
                    // find for a given builder is its most recent.
                    "color": build.color,
                    "flaky": false,
                    "ignoreFailure": false,
                };
                var split = builder.split("-");
                if (split.length > 2) {
                  builderDetails.category = split[0];
                  builderDetails.subcategory = split[1];
                }
                if (builderDetails.comments.length > 0) {
                  builderDetails.flaky = !!builderDetails.comments[builderDetails.comments.length-1].flaky;
                  builderDetails.ignoreFailure = !!builderDetails.comments[builderDetails.comments.length-1].ignoreFailure
                }
                builders[builder] = builderDetails;
              }
              builds[builder][build.number] = build;
              // Figure out the display class to use.
              var clazz = "build_single";
              if (i > 0) {
                var prevCommit = commits[i-1];
                var prevDetails = buildDetails[prevCommit.hash];
                if (prevDetails) {
                  var prevBuild = prevDetails[builder];
                  if (prevBuild && prevBuild.number == build.number) {
                    clazz = "build_bottom";
                    if (prevCommit.displayClass[builder] == "build_single") {
                      prevCommit.displayClass[builder] = "build_top";
                    } else if (prevCommit.displayClass[builder] == "build_bottom") {
                      prevCommit.displayClass[builder] = "build_middle";
                    }
                  }
                }
              }
              commit.displayClass[builder] = clazz;
            }
          }
          that.builds = builds;
          that.buildDetails = buildDetails;
          that.allBuilders = builders;
          that.filterBuilders();
          if (that.autorollLast) {
            json.branch_heads.push({
                name: "last DEPS roll",
                head: that.autorollLast,
            });
          }
          if (that.autorollCurrent) {
            json.branch_heads.push({
              name: "current DEPS roll",
              head: that.autorollCurrent,
            });
          }
          console.log("Prepared build data.");
          console.timeEnd("processData");

          // Actually draw the commits.
          that.commits = commits;
          that.branchHeads = json.branch_heads;
          that.draw();
          console.timeEnd("totalLoadTime");
        }).then(function() {
          that.resetTimeout();
          if (that.$) {
            that.$.loading.active = false;
            that.$.loading.display = "none";
          }
        }, function() {
          that.resetTimeout();
          if (that.$) {
            that.$.loading.active = false;
            that.$.loading.display = "none";
          }
        });
      },

      draw: function() {
        console.time("draw");
        var commits = this.commits;
        var branchHeads = this.branchHeads;
        console.log("Drawing.");
        // Initialize all commits.
        var prep = prepareCommitsForDisplay(commits, branchHeads);
        this.displayCommits = prep[0];
        var numColumns = prep[1];

        // Calculate the required canvas width based on the commit columns and
        // labels.
        // TODO(borenet): Further minimize this width by reordering the columns
        // based on which has the longest label.
        var dummyCtx = document.createElement("canvas").getContext("2d");
        dummyCtx.font = font;
        var longestWidth = 0;
        for (var i = 0; i < commits.length; i++) {
          var c = this.displayCommits[commits[i].hash];
          var w = c.labelWidth(dummyCtx);
          w += commitY * (c.column + 1);
          if (w > longestWidth) {
            longestWidth = w;
          }
        }

        // Redraw the canvas.
        var scale = window.devicePixelRatio || 1.0;
        var canvas = this.shadowRoot.getElementById("commitCanvas");
        this.canvasWidth = Math.max(longestWidth + paddingX, this.minCanvasWidth);
        this.canvasHeight = commitY * commits.length;
        canvas.style.width = Math.floor(this.canvasWidth) + "px";
        canvas.style.height = Math.floor(this.canvasHeight) + "px";
        canvas.width = this.canvasWidth * scale;
        canvas.height = this.canvasHeight * scale;
        var ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.setTransform(scale, 0, 0, scale, 0, 0);
        ctx.font = font;

        // Shade an alternating background.
        for (var i = 0; i < commits.length; i++) {
          this.displayCommits[commits[i].hash].drawBackground(ctx);
        }

        // Draw the commits.
        for (var i = 0; i < commits.length; i++) {
          this.displayCommits[commits[i].hash].draw(ctx, this.displayCommits);
        }

        // Get the build table width.
        this.windowWidth = this.$.container.offsetWidth;
        this.windowHeight = this.$.container.offsetHeight;
        this.buildTableWidth = this.windowWidth - this.canvasWidth - this.authorWidth - this.commentIndicatorWidth - this.revertIndicatorWidth - 4;
        console.timeEnd("draw");
      },

      setBuilderWidth: function() {
        this.builderWidth = Math.max(Math.floor(this.buildTableWidth / this.numBuilders) - 1, 1);
      },

      buildTableWidthChanged: function() {
        this.setBuilderWidth();
      },

      numBuildersChanged: function() {
        this.setBuilderWidth();
      },

      setFilterToSearch: function() {
        this.builderFilter = "search";
      },

      builderSearchChanged: function() {
        // This callback fires every time the user presses a key inside the
        // input box. Updating the display can be really slow when there are
        // a lot of builders, so we should wait until the user is done typing
        // before re-filtering.
        if (this.builderSearchChangedTimeout) {
          window.clearTimeout(this.builderSearchChangedTimeout);
        }
        var that = this;
        this.builderSearchChangedTimeout = window.setTimeout(function() {
          that.builderSearchChangedTimeout = null;

          // If "search" is already selected, filter the builders.
          if (that.builderFilter == "search") {
            that.filterBuilders();
          }
        }, 600);
      },

      shouldHighlight: function(commit) {
        for (var i = 0; i < this.highlightedCommits.length; i++) {
          if (commit.indexOf(this.highlightedCommits[i]) == 0) {
            return true;
          }
        }
        return false;
      },
    });
  })();
  </script>
</polymer-element>
