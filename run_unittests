#!/usr/bin/env python
# Copyright (c) 2012 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

"""Runs all unit tests under this base directory."""

import os
import subprocess
import sys
import unittest


BUILDBOT_PATH = os.path.dirname(os.path.abspath(__file__))


GO_TESTS = [
  '.',
  'perf',
  'monitoring',
]

GO_TEST_FAILED = (
'''======================================================================
Go test failed: %s
----------------------------------------------------------------------
%s
----------------------------------------------------------------------
''')

NO_CRAWL_DIRS = [
  '.git',
  '.svn',
  'autoroll_git',
  'common',
  'git_poller_skia.git',
  'third_party',
]


def FilterDirectory(dirpath, filenames):
  """ Determine whether to look for tests in the given directory.

  dirpath: string; path of the directory in question.
  filenames: list of strings; the files in the directory.
  """
  if not dirpath or not filenames:
    return False
  for no_crawl_dir in NO_CRAWL_DIRS:
    if no_crawl_dir in dirpath:
      return False
  return True


def TestGo(testname):
  # TODO(borenet): Switch to 'make test' once we're sure the karma-based tests
  # will run in headless mode.
  p = subprocess.Popen(['make', 'testgo'], cwd=testname,
                       stderr=subprocess.STDOUT,
                       stdout=subprocess.PIPE)
  output = p.communicate()[0]
  if p.returncode != 0:
    return GO_TEST_FAILED % (testname, output)
  return None


if __name__ == '__main__':
  print 'Searching for tests.'
  tests_to_run = []

  for (dirpath, dirnames, filenames) in os.walk(BUILDBOT_PATH, topdown=True):
    dirnames[:] = [d for d in dirnames if not d in NO_CRAWL_DIRS]
    test_modules = [os.path.join(dirpath, filename) for filename in filenames
                    if filename.endswith('_test.py')]
    if not test_modules:
      continue
    tests_to_run.extend(test_modules)

  print 'Found %d tests.' % (len(tests_to_run) + len(GO_TESTS))
  errors = []
  for test in tests_to_run:
    proc = subprocess.Popen(['python', test], stdout=subprocess.PIPE,
                            stderr=subprocess.STDOUT)
    if proc.wait() != 0:
      errors.append(proc.communicate()[0])

  for go_test in GO_TESTS:
    error = TestGo(go_test)
    if error:
      errors.append(error)

  if errors:
    for error in errors:
      print error
    print 'Failed %d of %d.' % (len(errors), len(tests_to_run) + len(GO_TESTS))
    sys.exit(1)
  else:
    print 'All tests succeeded.'
