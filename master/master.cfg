# Copyright (c) 2011 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import os

# These modules come from $(TOPLEVEL_DIR)/scripts ,
# which must be in the PYTHONPATH.
from buildbot.status.web.baseweb import WebStatus
from master import gatekeeper
from master import master_utils
from master import slaves_list
from master.status_push import TryServerHttpStatusPush

import skia_notifier

# This module comes from $(TOPLEVEL_DIR)/site_config ,
# which must be in the PYTHONPATH.
import config

# These modules come from the local directory.
from skia_master_scripts import monkeypatches
from skia_master_scripts import utils
from webstatus import buildstatus
from webstatus import console
from webstatus import waterfall
import builder_name_schema
import master_builders_cfg
import master_private_builders_cfg
import master_source_cfg


c = BuildmasterConfig = {}
c['change_source'] = []
c['schedulers'] = []
c['builders'] = []
c['status'] = []


def GetSkiaGateKeeper():
  """Returns the GateKeeper used by Skia.

  If any of the bots in the Build category (compile bots) fails the specified
  build steps, then the tree is automatically closed and an email is sent about
  the tree closure.

  Note: The tree is not closed if the last run of the builder had the same
        failing step as the current run. The tree is also not closed if the
        gatekeeper closed the tree less than 10 mins ago.
  """
  # Run the gatekeeper only on the following categories and build steps.
  categories_steps = {
      builder_name_schema.BUILDER_ROLE_BUILD: [
          'Retry_BuildAll',
          'Retry_BuildBench',
          'Retry_BuildGm',
          'Retry_BuildMost',
          'Retry_BuildSkiaLib',
          'Retry_BuildTests',
          'Retry_BuildTools',
      ],
  }
  return gatekeeper.GateKeeper(
      fromaddr=config.Master.Skia.from_address,
      categories_steps=categories_steps,
      exclusions={},
      relayhost=config.Master.smtp,
      subject='buildbot %(result)s in %(projectName)s on %(builder)s, '
              'revision %(revision)s',
      extraRecipients=config.Master.Skia.tree_closing_notification_recipients,
      lookup=master_utils.FilterDomain(),
      forgiving_steps=[],
      tree_status_url=config.Master.Skia.tree_status_url,
      check_revisions=True)


if os.environ.get('PRIVATE_MASTER'):
  ActiveMaster = config.Master.PrivateSkia
  master_source_cfg.Update(config, ActiveMaster, c)
  master_private_builders_cfg.Update(config, ActiveMaster, c)
  # Associate the slaves to the manual builders. The configuration is in
  # private_slaves.cfg.
  slaves = slaves_list.SlavesList('private_slaves.cfg', ActiveMaster.__name__)
else:
  ActiveMaster = config.Master.Skia
  master_source_cfg.Update(config, ActiveMaster, c)
  master_builders_cfg.Update(config, ActiveMaster, c)
  # Associate the slaves to the manual builders. The configuration is in
  # slaves.cfg.
  slaves = slaves_list.SlavesList('slaves.cfg', ActiveMaster.__name__)


for builder in c['builders']:
  builder['slavenames'] = slaves.GetSlavesName(builder=builder['name'])


# The 'slaves' list defines the set of allowable buildslaves. List all the
# slaves registered to a builder. Remove dupes.
c['slaves'] = master_utils.AutoSetupSlaves(c['builders'],
                                           config.Master.GetBotPassword())
master_utils.VerifySetup(c, slaves)

# For each slave instance, add the key/value pairs in its associated dictionary,
# defined in slaves.cfg, to its build properties. This allows us to access
# extra attributes defined in slaves.cfg using WithProperties.
for slave_instance in c['slaves']:
  for slave_dict in slaves.GetSlaves():
    if slave_dict['hostname'] == slave_instance.identity()[0]:
      slave_instance.properties.update(slave_dict, 'BuildSlave')
      break

# Adds common status and tools to this master.
c['buildbotURL'] = 'http://%s:%d/' % (
    ActiveMaster.master_host, ActiveMaster.master_port_alt)
master_utils.AutoSetupMaster(c, ActiveMaster, mail_notifier=False)

# Replace the default console and waterfall pages with our overrides and add
# the trybot and failures waterfalls.
for status in c['status']:
  if issubclass(status.__class__, WebStatus):
    status.putChild('console', console.ConsoleStatusResource())
    status.putChild('waterfall', waterfall.WaterfallStatusResource())
    status.putChild('trybots', waterfall.TrybotStatusResource())
    status.putChild('failures', waterfall.FailureWaterfallStatusResource())
    status.putChild('buildstatus', buildstatus.BuildStatusStatusResource())


# Add our own mail notifier (only in production mode):
# email the committer (and skia-commit list) only if it changed test results
if ActiveMaster.is_production_host:
  mail_notifier = skia_notifier.SkiaNotifier(
      fromaddr=ActiveMaster.from_address,
      sendToInterestedUsers=True,
      extraRecipients=['skia-commit@googlegroups.com'],
      mode='change',
      relayhost=config.Master.smtp,
      lookup=master_utils.FilterDomain(
          permitted_domains=config.Master.permitted_domains))
  c['status'].append(mail_notifier)

  # Try job result emails.
  c['status'].append(skia_notifier.SkiaTryMailNotifier(
      fromaddr=ActiveMaster.from_address,
      # Subject is overridden in skia_notifier.SkiaTryMailNotifier.buildMessage
      subject='try %(result)s for changelist "%(reason)s" at %(timestamp)s',
      mode='all',
      relayhost=config.Master.smtp,
      lookup=master_utils.FilterDomain(
          permitted_domains=config.Master.permitted_domains),
      footer="""Skia Trybot documentation: <a href=
"https://sites.google.com/site/skiadocs/developer-documentation/skia-trybots">
https://sites.google.com/site/skiadocs/developer-documentation/skia-trybots</a>
<br/></body></html>"""))

  c['status'].append(
      TryServerHttpStatusPush(serverUrl=ActiveMaster.code_review_site))

  # Add the gatekeeper
  c['status'].append(GetSkiaGateKeeper())


c['mergeRequests'] = utils.CanMergeBuildRequests
